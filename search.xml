<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JS中的模块化</title>
      <link href="/2022/07/14/js-modules/"/>
      <url>/2022/07/14/js-modules/</url>
      
        <content type="html"><![CDATA[<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>&emsp;&emsp;在平时开发的时候经常会接触到很多js模块化的语法，如import、export、require、module.export等，但是在自己使用export时，就会有一些疑问：</p><ul><li>require和import都是可以引用js模块，这两个有什么区别？</li><li>export可以直接输出变量，export default为什么有时候就会报错？</li><li><code>import {a, b} from &#39;moduleJs&#39;</code> 和 <code>import c from &#39;moduleJs&#39;</code> 有什么区别？</li></ul><p>&emsp;&emsp;带着这些疑问就开始了js模块化的探索</p><h2 id="什么是模块化"><a href="#什么是模块化" class="headerlink" title="什么是模块化"></a>什么是模块化</h2><p>&emsp;&emsp;模块化就是将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来，如同乐高积木一样。具体到js应用开发，可以将每个独立功能看做一个模块，以一个js文件的形式展示，通过规定的方式向外暴露指定的内容，并且每个模块可以通过规定的方式引入。</p><h2 id="模块化规范"><a href="#模块化规范" class="headerlink" title="模块化规范"></a>模块化规范</h2><p>&emsp;&emsp;经过多年的发展，目前js模块化的规范主要有以下三个：</p><ul><li>CommonJS，Node.js实现的模块化规范</li><li>AMD，受到CommonJS启发，推出的适用于浏览器端的JS模块化规范</li><li>ES6中的模块化，官方推出的js模块化标准</li></ul><p>&emsp;&emsp;目前我们经常使用的import和export命令，就是ES6中定义的模块化规范。而我们时常会看到的require命令，是出自CommonJS规范。<br>&emsp;&emsp;而import和require目前在vue的工程化程序中都可以使用，那有什么区别呢？这块后续有时间再进行研究了</p><h2 id="ES6中的模块化规范"><a href="#ES6中的模块化规范" class="headerlink" title="ES6中的模块化规范"></a>ES6中的模块化规范</h2><h4 id="1、export和import的使用"><a href="#1、export和import的使用" class="headerlink" title="1、export和import的使用"></a>1、export和import的使用</h4><p>模块功能主要由两个命令构成：<code>export</code>和<code>import</code>。<code>export</code>命令用于规定模块的对外接口，<code>import</code>命令用于输入其他模块提供的功能。最基本的用法如下：<br>我们在a.js文件中定义了用户信息，并用export命令输出对应变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a.js</span><br><span class="line">var firstName &#x3D; &#39;Michael&#39;;</span><br><span class="line">var lastName &#x3D; &#39;Jackson&#39;;</span><br><span class="line">var year &#x3D; 1958;</span><br><span class="line"> </span><br><span class="line">export &#123;firstName, lastName, year&#125;;</span><br></pre></td></tr></table></figure><p>然后在index.js中，使用import介绍a.js中的信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123;firstName, lastName, year&#125; from &#39;.&#x2F;a.js&#39;;</span><br></pre></td></tr></table></figure><p>除了变量，export命令还可以输出行数或者类（class）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a.js输出方法</span><br><span class="line">export function consoleT() &#123;</span><br><span class="line">  console.log(&#39;module a test&#39;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; index.js 使用方法</span><br><span class="line">import &#123;consoleT&#125; from &#39;.&#x2F;a&#39;</span><br><span class="line">consoleT()</span><br></pre></td></tr></table></figure><h4 id="2、export-default"><a href="#2、export-default" class="headerlink" title="2、export default"></a>2、export default</h4><p>刚刚的例子中<code>import {xxx} from &#39;xxx&#39;</code> 都加了{}中括号，而我们平时使用import时，都是直接使用 <code>import xxx from &#39;xxx&#39;</code>。如果我们在第二个例子中不添加中括号时，直接引用函数会有什么问题？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a.js输出方法</span><br><span class="line">export function consoleT() &#123;</span><br><span class="line">  console.log(&#39;module a test&#39;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; index.js 使用方法</span><br><span class="line">import consoleT from &#39;.&#x2F;a&#39;</span><br><span class="line">consoleT()</span><br></pre></td></tr></table></figure><p>使用webpack编译时，会有以下问题，警告<code>consoleT</code>未找到<br><code>export &#39;default&#39; (imported as &#39;consoleT&#39;) was not found in &#39;./a&#39; (possible exports: consoleT, firstName, lastName, year)</code></p><p>从警告中可以看到，有个default，我们使用 <code>export default</code>命令就可以解决以上问题，从default这个单词可以看出，它是用来为模块指定默认输出用的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; a.js</span><br><span class="line"></span><br><span class="line">export default function () &#123;</span><br><span class="line">  console.log(&#39;module a default&#39;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; index.js</span><br><span class="line">import a from &#39;.&#x2F;a&#39;</span><br><span class="line">a()</span><br></pre></td></tr></table></figure><p>这样就不需要{}中括号了，而且在引用时，可以使用任意名称，如<code>import abc from &#39;./a&#39;</code></p><p>本质上，export default就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; modules.js</span><br><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x * y;</span><br><span class="line">&#125;</span><br><span class="line">export &#123;add as default&#125;;</span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">&#x2F;&#x2F; export default add;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; app.js</span><br><span class="line">import &#123; default as foo &#125; from &#39;modules&#39;;</span><br></pre></td></tr></table></figure><p>正是因为export default命令其实只是输出一个叫做default的变量，所以它后面不能跟变量声明语句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 正确</span><br><span class="line">export var a &#x3D; 1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 正确</span><br><span class="line">var a &#x3D; 1;</span><br><span class="line">export default a;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 错误</span><br><span class="line">export default var a &#x3D; 1;</span><br></pre></td></tr></table></figure><h4 id="3、import"><a href="#3、import" class="headerlink" title="3、import()"></a>3、import()</h4><p><code>import</code>命令会将引入的模块做静态处理，就是在编译阶段，就会将文件引入，所以在我们想要动态引入模块时，使用<code>import</code>会报错。<br>为了解决这个问题，在ES 2020中引入了<code>import()</code>函数，支持动态加载模块。</p><p>import()返回一个 Promise 对象。下面是一个例子。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import(&#96;.&#x2F;section-modules&#x2F;$&#123;someVariable&#125;.js&#96;)</span><br><span class="line">.then(module &#x3D;&gt; &#123;</span><br><span class="line">  module.loadPageInto(main);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(err &#x3D;&gt; &#123;</span><br><span class="line">  console.log(err.message);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://es6.ruanyifeng.com/#docs/module" target="_blank" rel="noopener">ECMAScript6入门-Module语法</a><br><a href="https://www.ruanyifeng.com/blog/2012/10/javascript_module.html" target="_blank" rel="noopener">JavaScript模块化编程</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发技能 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WEB </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android通过配置Flavors修改应用图标</title>
      <link href="/2020/01/30/android-flover/"/>
      <url>/2020/01/30/android-flover/</url>
      
        <content type="html"><![CDATA[<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>由于项目需求，有个客户要求对产品的图标和启动页面进行了个性化，这样就引发了两个打包问题：</p><p>1.需要单独给该客户打包</p><p>2.打包过程过于繁琐。打完一个包后，还要替换图标再打另一个。</p><p>这对于习惯偷懒的我来说，是不能容忍的。所以便开始寻找可以自动化且多渠道打包的方案。而Android Studio也相当给力的提供Flavors这一解决方案。</p><h2 id="什么是Flavor"><a href="#什么是Flavor" class="headerlink" title="什么是Flavor"></a>什么是Flavor</h2><p>&emsp;&emsp;Flavor直译过来是“风味/口味”的意思，官方这样命名，应该就是将Android应用看做成一道菜，可以通过不同“口味”的配置，最终可以呈现出的多种不同“风味”的菜品。这个命名已符合Android一贯的习性，从Android历代版本的版本代号就不难看出，什么蛋糕、甜甜圈、泡芙、棒棒糖、奥利奥、馅饼等等，都是和吃相关的，这是一群多么喜欢吃的团队啊。</p><p>&emsp;&emsp;现在拉回正题，相对而言，我更喜欢将Flavor称为“渠道”，这样对我而言更好理解一些。而配置渠道Flavor的方式非常简单，只需要将他们添加到productFlavors{}代码块中就可以了。而好巧不巧，defaultConfig居然是productFlavors的子类，每个渠道Flavor的配置都支持与defaultConfig相同的属性，所以们可以在defaultConfig中配置每个渠道Flavor的基础配置，如applicationId，而每个渠道Flavor也可以修改这些配置。所以渠道中的配置会覆盖defaultConfig中的配置，但是如果在buildType中有相同的配置，渠道Flavor中的配置会被覆盖，具体配置的优先级如下：</p><p>&emsp;&emsp;按优先级从高到低: buildType-&gt;Flavor-&gt;defaultConfig</p><p>&emsp;&emsp;了解了Flavor的基本信息后，我们就可以开始动手解决问题了。</p><h2 id="使用Flavors修改图标"><a href="#使用Flavors修改图标" class="headerlink" title="使用Flavors修改图标"></a>使用Flavors修改图标</h2><h4 id="一、配置渠道"><a href="#一、配置渠道" class="headerlink" title="一、配置渠道"></a>一、配置渠道</h4><p>首先需要在build.gradle中添加productFlavors，并且在productFlavors中配置对应的渠道，用来表示不同的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">productFlavors &#123;</span><br><span class="line">  huawei &#123;&#125;</span><br><span class="line">  oppo &#123;&#125;</span><br><span class="line">  vivo &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在各个渠道中，如果有需要，可以修改对应渠道的applicationId、versionName等值，如果没有配置，会默认的使用defaultConfig里面的属性。</p><h4 id="二、资源文件配置"><a href="#二、资源文件配置" class="headerlink" title="二、资源文件配置"></a>二、资源文件配置</h4><p>在build.gradle我们添加了三个渠道，相应的需要在app/src中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">├── androidTest</span><br><span class="line">├── main</span><br><span class="line">├── libs</span><br><span class="line">├── huawei</span><br><span class="line">└── oppo</span><br><span class="line">└── vivo</span><br></pre></td></tr></table></figure><p>然后在需要替换应用图标的文件夹中添加res资源文件夹，并添加进对应的应用图标文件，注意目录、文件名需要一致，这样构建应用时会替换main中的资源文件。</p>]]></content>
      
      
      <categories>
          
          <category> 开发技能 </category>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
